{
  "version": 3,
  "sources": ["../@themesberg/tailwind-datepicker/js/DateRangePicker.js"],
  "sourcesContent": ["import {registerListeners, unregisterListeners} from './lib/event.js';\nimport {formatDate} from './lib/date-format.js';\nimport Datepicker from './Datepicker.js';\n\n// filter out the config options inapproprite to pass to Datepicker\nfunction filterOptions(options) {\n  const newOpts = Object.assign({}, options);\n\n  delete newOpts.inputs;\n  delete newOpts.allowOneSidedRange;\n  delete newOpts.maxNumberOfDates; // to ensure each datepicker handles a single date\n\n  return newOpts;\n}\n\nfunction setupDatepicker(rangepicker, changeDateListener, el, options) {\n  registerListeners(rangepicker, [\n    [el, 'changeDate', changeDateListener],\n  ]);\n  new Datepicker(el, options, rangepicker);\n}\n\nfunction onChangeDate(rangepicker, ev) {\n  // to prevent both datepickers trigger the other side's update each other\n  if (rangepicker._updating) {\n    return;\n  }\n  rangepicker._updating = true;\n\n  const target = ev.target;\n  if (target.datepicker === undefined) {\n    return;\n  }\n\n  const datepickers = rangepicker.datepickers;\n  const setDateOptions = {render: false};\n  const changedSide = rangepicker.inputs.indexOf(target);\n  const otherSide = changedSide === 0 ? 1 : 0;\n  const changedDate = datepickers[changedSide].dates[0];\n  const otherDate = datepickers[otherSide].dates[0];\n\n  if (changedDate !== undefined && otherDate !== undefined) {\n    // if the start of the range > the end, swap them\n    if (changedSide === 0 && changedDate > otherDate) {\n      datepickers[0].setDate(otherDate, setDateOptions);\n      datepickers[1].setDate(changedDate, setDateOptions);\n    } else if (changedSide === 1 && changedDate < otherDate) {\n      datepickers[0].setDate(changedDate, setDateOptions);\n      datepickers[1].setDate(otherDate, setDateOptions);\n    }\n  } else if (!rangepicker.allowOneSidedRange) {\n    // to prevent the range from becoming one-sided, copy changed side's\n    // selection (no matter if it's empty) to the other side\n    if (changedDate !== undefined || otherDate !== undefined) {\n      setDateOptions.clear = true;\n      datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);\n    }\n  }\n  datepickers[0].picker.update().render();\n  datepickers[1].picker.update().render();\n  delete rangepicker._updating;\n}\n\n/**\n * Class representing a date range picker\n */\nexport default class DateRangePicker  {\n  /**\n   * Create a date range picker\n   * @param  {Element} element - element to bind a date range picker\n   * @param  {Object} [options] - config options\n   */\n  constructor(element, options = {}) {\n    const inputs = Array.isArray(options.inputs)\n      ? options.inputs\n      : Array.from(element.querySelectorAll('input'));\n    if (inputs.length < 2) {\n      return;\n    }\n\n    element.rangepicker = this;\n    this.element = element;\n    this.inputs = inputs.slice(0, 2);\n    this.allowOneSidedRange = !!options.allowOneSidedRange;\n\n    const changeDateListener = onChangeDate.bind(null, this);\n    const cleanOptions = filterOptions(options);\n    // in order for initial date setup to work right when pcicLvel > 0,\n    // let Datepicker constructor add the instance to the rangepicker\n    const datepickers = [];\n    Object.defineProperty(this, 'datepickers', {\n      get() {\n        return datepickers;\n      },\n    });\n    setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);\n    setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);\n    Object.freeze(datepickers);\n    // normalize the range if inital dates are given\n    if (datepickers[0].dates.length > 0) {\n      onChangeDate(this, {target: this.inputs[0]});\n    } else if (datepickers[1].dates.length > 0) {\n      onChangeDate(this, {target: this.inputs[1]});\n    }\n  }\n\n  /**\n   * @type {Array} - selected date of the linked date pickers\n   */\n  get dates() {\n    return this.datepickers.length === 2\n      ? [\n          this.datepickers[0].dates[0],\n          this.datepickers[1].dates[0],\n        ]\n      : undefined;\n  }\n\n  /**\n   * Set new values to the config options\n   * @param {Object} options - config options to update\n   */\n  setOptions(options) {\n    this.allowOneSidedRange = !!options.allowOneSidedRange;\n\n    const cleanOptions = filterOptions(options);\n    this.datepickers[0].setOptions(cleanOptions);\n    this.datepickers[1].setOptions(cleanOptions);\n  }\n\n  /**\n   * Destroy the DateRangePicker instance\n   * @return {DateRangePicker} - the instance destroyed\n   */\n  destroy() {\n    this.datepickers[0].destroy();\n    this.datepickers[1].destroy();\n    unregisterListeners(this);\n    delete this.element.rangepicker;\n  }\n\n  /**\n   * Get the start and end dates of the date range\n   *\n   * The method returns Date objects by default. If format string is passed,\n   * it returns date strings formatted in given format.\n   * The result array always contains 2 items (start date/end date) and\n   * undefined is used for unselected side. (e.g. If none is selected,\n   * the result will be [undefined, undefined]. If only the end date is set\n   * when allowOneSidedRange config option is true, [undefined, endDate] will\n   * be returned.)\n   *\n   * @param  {String} [format] - Format string to stringify the dates\n   * @return {Array} - Start and end dates\n   */\n  getDates(format = undefined) {\n    const callback = format\n      ? date => formatDate(date, format, this.datepickers[0].config.locale)\n      : date => new Date(date);\n\n    return this.dates.map(date => date === undefined ? date : callback(date));\n  }\n\n  /**\n   * Set the start and end dates of the date range\n   *\n   * The method calls datepicker.setDate() internally using each of the\n   * arguments in start\u2192end order.\n   *\n   * When a clear: true option object is passed instead of a date, the method\n   * clears the date.\n   *\n   * If an invalid date, the same date as the current one or an option object\n   * without clear: true is passed, the method considers that argument as an\n   * \"ineffective\" argument because calling datepicker.setDate() with those\n   * values makes no changes to the date selection.\n   *\n   * When the allowOneSidedRange config option is false, passing {clear: true}\n   * to clear the range works only when it is done to the last effective\n   * argument (in other words, passed to rangeEnd or to rangeStart along with\n   * ineffective rangeEnd). This is because when the date range is changed,\n   * it gets normalized based on the last change at the end of the changing\n   * process.\n   *\n   * @param {Date|Number|String|Object} rangeStart - Start date of the range\n   * or {clear: true} to clear the date\n   * @param {Date|Number|String|Object} rangeEnd - End date of the range\n   * or {clear: true} to clear the date\n   */\n  setDates(rangeStart, rangeEnd) {\n    const [datepicker0, datepicker1] = this.datepickers;\n    const origDates = this.dates;\n\n    // If range normalization runs on every change, we can't set a new range\n    // that starts after the end of the current range correctly because the\n    // normalization process swaps start\u2194\uFE0Eend right after setting the new start\n    // date. To prevent this, the normalization process needs to run once after\n    // both of the new dates are set.\n    this._updating = true;\n    datepicker0.setDate(rangeStart);\n    datepicker1.setDate(rangeEnd);\n    delete this._updating;\n\n    if (datepicker1.dates[0] !== origDates[1]) {\n      onChangeDate(this, {target: this.inputs[1]});\n    } else if (datepicker0.dates[0] !== origDates[0]) {\n      onChangeDate(this, {target: this.inputs[0]});\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
